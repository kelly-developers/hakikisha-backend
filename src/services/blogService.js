const Blog = require('../models/Blog');
const logger = require('../utils/logger');

class BlogService {
  /**
   * Get blogs with filtering and pagination
   */
  async getBlogs(options = {}) {
    try {
      const { category, limit = 10, offset = 0, author } = options;
      
      if (author === 'current') {
        // This would require the user ID from the request
        throw new Error('Author filtering requires authentication');
      }
      
      if (category) {
        return await Blog.findByCategory(category, limit, offset);
      }
      
      // Default: get all published blogs
      return await Blog.getAll(limit, offset);
    } catch (error) {
      logger.error('BlogService - Get blogs error:', error);
      throw error;
    }
  }

  /**
   * Get blog by ID
   */
  async getBlogById(id) {
    try {
      return await Blog.findById(id);
    } catch (error) {
      logger.error('BlogService - Get blog by ID error:', error);
      throw error;
    }
  }

  /**
   * Get trending blogs
   */
  async getTrendingBlogs(limit = 5) {
    try {
      return await Blog.getTrendingBlogs(limit);
    } catch (error) {
      logger.error('BlogService - Get trending blogs error:', error);
      throw error;
    }
  }

  /**
   * Create a new blog
   */
  async createBlog(blogData) {
    try {
      return await Blog.create(blogData);
    } catch (error) {
      logger.error('BlogService - Create blog error:', error);
      throw error;
    }
  }

  /**
   * Update blog
   */
  async updateBlog(id, updateData) {
    try {
      return await Blog.update(id, updateData);
    } catch (error) {
      logger.error('BlogService - Update blog error:', error);
      throw error;
    }
  }

  /**
   * Delete blog
   */
  async deleteBlog(id) {
    try {
      return await Blog.delete(id);
    } catch (error) {
      logger.error('BlogService - Delete blog error:', error);
      throw error;
    }
  }

  /**
   * Increment view count
   */
  async incrementViewCount(id) {
    try {
      return await Blog.updateViewCount(id);
    } catch (error) {
      logger.error('BlogService - Increment view count error:', error);
      throw error;
    }
  }

  /**
   * Publish blog
   */
  async publishBlog(id) {
    try {
      return await Blog.publish(id);
    } catch (error) {
      logger.error('BlogService - Publish blog error:', error);
      throw error;
    }
  }

  /**
   * Search blogs
   */
  async searchBlogs(queryText, options = {}) {
    try {
      const { limit = 10, offset = 0 } = options;
      return await Blog.search(queryText, limit, offset);
    } catch (error) {
      logger.error('BlogService - Search blogs error:', error);
      throw error;
    }
  }

  /**
   * Generate AI blog
   */
  async generateAIBlog(options) {
    try {
      const { topic, claims, tone, length, author_id } = options;
      
      // This is a placeholder for AI blog generation
      // In a real implementation, you would call an AI service like OpenAI
      const aiContent = await this.callAIService({
        topic,
        claims,
        tone,
        length
      });

      const blogData = {
        title: `AI Generated: ${topic}`,
        content: aiContent,
        author_id: author_id,
        author_type: 'ai',
        category: 'fact_check',
        source_claim_ids: claims || [],
        status: 'draft'
      };

      return await Blog.create(blogData);
    } catch (error) {
      logger.error('BlogService - Generate AI blog error:', error);
      throw error;
    }
  }

  /**
   * Placeholder for AI service call
   */
  async callAIService(options) {
    // This is a mock implementation
    // Replace with actual AI service integration
    const { topic, claims, tone, length } = options;
    
    return `
      # ${topic}

      This is an AI-generated blog post about "${topic}".

      ## Key Points:
      ${claims && claims.length > 0 ? 
        claims.map(claim => `- ${claim}`).join('\n      ') : 
        '- No specific claims provided'
      }

      ## Analysis:
      Based on the available information, this topic requires careful fact-checking and analysis.

      ## Conclusion:
      Always verify information from multiple reliable sources before drawing conclusions.

      *This content was generated by AI and should be reviewed by human fact-checkers.*
    `;
  }

  /**
   * Get blog statistics
   */
  async getBlogStats() {
    try {
      const db = require('../config/database');
      
      const totalQuery = 'SELECT COUNT(*) as total FROM hakikisha.blog_articles WHERE status = $1';
      const publishedQuery = 'SELECT COUNT(*) as published FROM hakikisha.blog_articles WHERE status = $1';
      const viewsQuery = 'SELECT SUM(COALESCE(view_count, 0)) as total_views FROM hakikisha.blog_articles';
      const authorsQuery = 'SELECT COUNT(DISTINCT author_id) as total_authors FROM hakikisha.blog_articles';

      const [totalResult, publishedResult, viewsResult, authorsResult] = await Promise.all([
        db.query(totalQuery, ['published']),
        db.query(publishedQuery, ['published']),
        db.query(viewsQuery),
        db.query(authorsQuery)
      ]);

      return {
        total: parseInt(totalResult.rows[0].total),
        published: parseInt(publishedResult.rows[0].published),
        total_views: parseInt(viewsResult.rows[0].total_views) || 0,
        total_authors: parseInt(authorsResult.rows[0].total_authors)
      };
    } catch (error) {
      logger.error('BlogService - Get blog stats error:', error);
      throw error;
    }
  }

  /**
   * Get blogs by author
   */
  async getBlogsByAuthor(authorId, options = {}) {
    try {
      const { limit = 10, offset = 0 } = options;
      return await Blog.getByAuthor(authorId, limit, offset);
    } catch (error) {
      logger.error('BlogService - Get blogs by author error:', error);
      throw error;
    }
  }
}

module.exports = new BlogService();